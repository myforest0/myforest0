---
title: 前端工程化
urlname: eoh5tn
date: '2021-06-07 09:49:08'
updated: '2024-02-04 16:02:30'
description: 在没有Node的远古时代，面对复杂的项目结构往往束手无策，即使采用变量模块化、等一些代码抽象的手段，还是不尽如人意。那么此时就有一个划时代的英雄出现了，它就是Node，如果说Ajax给前端能力范围带来了一次革命，那么Node也同样给前端工程化带来一次伟大的革命！工程化概述前端工程化是指遵循一定...
---
在没有Node的远古时代，面对复杂的项目结构往往束手无策，即使采用变量模块化、等一些代码抽象的手段，还是不尽如人意。那么此时就有一个划时代的英雄出现了，它就是Node，如果说Ajax给前端能力范围带来了一次革命，那么Node也同样给前端工程化带来一次伟大的革命！

## 工程化概述
前端工程化是指遵循一定标准和规范，通过工具去提升效率，他是一种降低成本的手段。

当下前端功能不断提高，业务复杂日益复杂。因此，在我们没有工程化之前，我们不得不面对一些问题：

- 想要使用ES6+新特性，但是兼容有问题
- 想要使用Less/Sass/PostCSS增强CSS的编程性，但是运行环境不能直接支持。
- 想要使用模块化的方式提高项目的可维护性，但是运行环境不能直接支持。
- 部署上线前需要**手动**压缩代码及资源文件，部署过程需要**手动**上传代码到服务器。
- 多人协作开发，无法硬性统一大家的代码风格，从仓库中pull的代码质量无法保证。
- 部分功能开发时需要等待后端服务接口提前完成
### 工程化主要解决的问题

- 传统语言或语法的弊端
- 无法使用模块化/组件化
- 重复的机械式工作
- 代码风格统一、质量保证
- 依赖后端服务接口支持
- 整体依赖后端项目
### 一个项目过程中工程化的表现
一切以提高效率、降低成本、质量保证为目的的手段都属于工程化。<br />一切重复的工作都应该被自动化，例如：创建项目一>编码一>预览/测试一>提交一>部署

### 工程化不等工具
工具不是工程化的核心，工程化的核心是对项目整体的规划、架构。而工具只是帮助我们去实现和落地的一种手段，例如文件的组织结构，源代码的开发范式(语法、规范、标准)<br />一些成熟的工程化集成有：create-react-app、vue-cli、angular-cli、gatsby-cli

工程化的一切都应该归功于Node.js，它让整个前端进行了一次工业革命，可以说，没有Node.js就没有现在的前端。因为几乎所有的工程化工具都是用Node.js来编写的。<br />但是，面对各种技术工具和新鲜名词，我们不必盲目追求，因为所有的工具都应该是为了解决问题而存在的。

从一个项目的开发过程开始，我们来了解前端工程化具体实现：
## 脚手架工具
自动帮助我们创建项目基础结构，并且提供项目规范和约定。<br />看似很普通的需求，背后却隐藏了一定的哲学。因为除了创建文件，它更重要的是还给开发者**提供了一套规范和约定**。<br />比如在开发类似项目时，他们都有以下特征：

- 相同的组织结构
- 相同的开发范式
- 相同的模块依赖
- 相同的工具配置
- 相同的基础代码

这导致我们在创建新项目时，有大量的重复工作要做，所以脚手架工具就是用来解决这一类问题的。我们可以通过脚手架快速搭建项目基础骨架，然后基于这个项目骨架来开发项目。<br />由于前端技术选型比较多样，另外也没有一个统一的标准，所以前端方向的脚手架不会集成在某个IDE中，它都是以一个独立的工具存在。
### Yeoman
是一个用于创建现代化web应用的脚手架工具。不同于`vue-cli`这样的工具，它更像一个脚手架的运行平台，我们可以通过`Yeoman`搭配不同的`generator`去创建任何类型的项目。也就是说，我们可以创建自己的`generator`，从而定制属于我们自己的前端的前端脚手架。

但是它的优点也是它的缺点，在专注于基于框架开发项目的人的眼中，它过于通用化，不够专注。所以他们更愿意使用`vue-cli`这种专注于某个框架的脚手架。
### Yeoman基本使用
#### 安装`Yeoman`
```shell
yarn global add yo
```
Yeoman是搭配特定的generator才能使用的，所以还需要安装generator
#### 安装对应的`generator`
```shell
yarn global add generator-node
```
#### 通过`yo`运行`generator`
```shell
yo node
```
然后根据提示输入项目的相关信息，完成后会自动生成项目。

### Sub Generator
有时候我们并不想安转完整的项目，仅仅只是想在原有的项目基础之上去增加部分文件。

例如我们想运行`generator-node`子集下面的cli命令，创建一个cli应用。
```shell
yo node:cli
```

## 自定义Generator
虽然市面上也有很多`generator`，但是他们并不包含我们自己项目的一些公用的依赖或者业务代码。所以，我们仍然有必要自己编写一个专属的`generator`。

### 创建Generator模块
generator本质上就是一个npm模块。不同于其他模块，yeoman的ganerator模块名称必须是generator-<name>的格式命名。
```shell
mkdir generator
cd generator
yarn init
yarn add yeoman-generator
```
上述命令完成后，接下来我们打开项目，然后在项目根目录创建`generators/app/index.js`文件<br />这个文件会作为`Generator`的核心入口<br />它需要导出一个继承自`Yeoman Generator`的类<br />Yeoman Generator 在工作时会自动调用我们在此类中定义的一些生命周期方法<br />我们在这些方法中可以调用父类提供的一些工具方法实现一些功能，例如文件写入。
```javascript
const Genetator = require("yeoman-generator")

module.exports = class extends Generator {
     writing() {
          // Yeoman 自动在生成文件阶段调用此方法
          this.fs.write(
             this.destinationPath("temp.txt"),
             Math.random().toString()
          )
     }
}
```
然后我们把这个模块，挂载到本地全局上
```shell
yarn link
```
接着就可以使用
```shell
yo simple  // simple 是上面创建项目定义的项目名称
```
### 根据模板创建文件
很多时候我们需要自动去创建的文件有很多，而且文件的内容也相对复杂，在这样的情况下，我们可以用模板来创建文件，因为这样更加便捷。<br />在app目录下创建`templates/foo.txt`文件，模板文件支持ejs模板引擎的模板语法，比如我们可以使用模板标记`<%= title %>`动态输出内容，也可以做一些判断、循环的操作。
```javascript
const Genetator = require("yeoman-generator")

module.exports = class extends Generator {
     writing() {
          // Yeoman 自动在生成文件阶段调用此方法
          // 模板文件路径
          const tmpl = this.templatePath("foo.txt")
          // 输出目标路径
          const output = this.destinationPath("foo.txt")
          // 模板数据上下文
          const context = {title: "Hello xsl~"}
          this.fs.copyTpl(tmpl, output, context)
     }
}
```
相对于手动创建每一个文件，通过模板创建大大提升了效率，特别是文件比较多比较复杂的情况下。

### 接收用户输入
```javascript
// ...
prompting() {
   // Yeoman 在询问用户环节会自动调用此方法
   //  在此方法中可以调用父类的prompt() 方法发出对用户的命令行询问
   return this.prompt([{
      type: "input",
      name: "name",
      message:"Your project name",
      default: this.appname, // appname为项目生成目录名称
   }]).then(answers => {
     this.answers = answers
   })
}
writing(){
   // ...
   this.fs.copyTpl(tmpl, output, this.answers)
}
```
## Plop
一个小而美的脚手架工具。主要创建项目中特定类型文件的小工具，它类似于Yeoman中的Sub Generator。不过它一般不会独立运行，它用来集成在项目当中，去创建同类型的项目文件。<br />在一个项目当中使用Plop，需要以下几个步骤：

1. 将Plop模块作为项目开发依赖安装
2. 在项目根目录下创建一个plopfile.js文件
3. 在plopfile.js文件中定义脚手架任务
4. 编写用于生成特定类型文件的模板
5. 通过Plop提供的CLI运行脚手架任务

## 脚手架工作原理
脚手架启动后，会先询问用户一些问题，然后根据这些问题的答案，结合一些模版文件去自动生成项目结构。

## 自动化构建
> 一切重复工作本应该自动化。自动化：让机器代替手工；构建：将A转换为B。

将开发环境的源代码自动化构建为生产环境可运行的代码。一般我们把这个转换的过程称为自动化构建工作流，它的作用是尽可能脱离运行环境兼容带来的问题，在开发环境阶段使用一些提高效率的语法、规范和标准。

自动化构建将那些不被支持的『特性』，转换为能够直接运行的代码，我们在开发过程中就可以尽情使用提高效率的代码了。

## NPM Scripts自动构建工作流
可以在package.json中定义一些与项目相关的构建命令，它是实现自动化构建工作流的最简方式。<br />在启动serve之前构建项目：
```json
// ...
"scripts": {
	"preserve": "yarn build",
  "serve": "browser-sync ."
}
```
同时执行多个任务：
```shell
yarn add npm-run-all
```
然后在scripts中添加：
```json
// ...
"scripts": {
	"build": "sass scss/main.scss css/style.css --watch",
  "serve": "browser-sync .",
  "start": "run-p build serve"
}
```
监听文件变化并重新编译，监听文件变化并自动热更新：
```json
// ...
"scripts": {
	"build": "sass scss/main.scss css/style.css --watch",
  "serve": "browser-sync . --files \“css/*.css\"",
  "start": "run-p build serve"
}
```

## 常见的自动化构建工具
> 严格意义上来说，Webpack属于模块化打包工具，所以不归类在此处

### Grunt
最早的前端构建系统，生态完善。因为它基于临时文件编译的，它在构建过程会对磁盘进行读写操作，所以构建速度会比较慢。例如它在工作时，上个插件将构建结果存储到一个临时文件中，下一个插件又会基于这个临时文件读取内容。如果处理的环节越多，那么对磁盘读写的次数也就会越多，也会更加耗时。

### Gulp
对于文件读写都是在内存中完成的，所以相对于磁盘读写操作，它的速度更快。同时他也支持多个任务同时执行。它的使用方式比Grunt更简单，生态也很完善，是目前前端构建最流行的系统。

### FIS
百度前端开源内部的构建系统，它把我们在项目中常见的需求都集成在内部了。例如资源加载、模块化开发、代码部署、性能优化。
































